using System;
using System.Collections.Generic;
using System.Diagnostics;
using dnlib.DotNet;
using dnlib.DotNet.Emit;

namespace Zexil.DotNet.FlowAnalysis {
	/// <summary>
	/// Block type
	/// </summary>
	public enum BlockType {
		/// <summary>
		/// Invalid value
		/// </summary>
		None,

		/// <summary>
		/// Basic block
		/// </summary>
		Basic,

		/// <summary>
		/// Try block
		/// </summary>
		Try,

		/// <summary>
		/// Filter block
		/// </summary>
		Filter,

		/// <summary>
		/// Catch block
		/// </summary>
		Catch,

		/// <summary>
		/// Finally block
		/// </summary>
		Finally,

		/// <summary>
		/// Fault block
		/// </summary>
		Fault,

		/// <summary>
		/// Method block
		/// </summary>
		Method
	}

	/// <summary>
	/// Block flags
	/// </summary>
	[Flags]
	public enum BlockFlags {
		/// <summary>
		/// None
		/// Target(s): <see cref="Block"/>
		/// </summary>
		None = 0,

		/// <summary>
		/// Generated by code
		/// Target(s): <see cref="Block"/>
		/// </summary>
		Generated = 1 << 0,

		/// <summary>
		/// Prevents to be inlined
		/// Target(s): <see cref="Block"/>
		/// </summary>
		NoInlining = 1 << 1,

		/// <summary>
		/// Trampoline, used for a scope block that has multiple entries
		/// Target(s): <see cref="BasicBlock"/>
		/// </summary>
		Trampoline = 1 << 2
	}

	/// <summary>
	/// Represents a context
	/// </summary>
	public abstract class Block {
		private BlockFlags _flags;
		private ScopeBlock? _scope;
		private readonly BlockContexts _contexts;

		/// <summary>
		/// Default constructor
		/// </summary>
		protected internal Block() {
			_contexts = new BlockContexts();
		}

		/// <summary>
		/// Block type
		/// </summary>
		public abstract BlockType Type { get; }

		/// <summary>
		/// Block flags
		/// </summary>
		public BlockFlags Flags {
			get => _flags;
			set => _flags = value;
		}

		/// <summary>
		/// Returns scope and throws if null
		/// </summary>
		public ScopeBlock Scope => ScopeNoThrow ?? throw new ArgumentNullException(nameof(ScopeNoThrow));

		/// <summary>
		/// Returns scope of current block
		/// </summary>
		public ScopeBlock? ScopeNoThrow {
			get => _scope;
			set => _scope = value;
		}

		/// <summary>
		/// Block contexts
		/// </summary>
		public BlockContexts Contexts => _contexts;

		/// <inheritdoc />
		public override string ToString() {
			return BlockFormatter.Format(this);
		}
	}

	/// <summary>
	/// Basic block
	/// </summary>
	public sealed class BasicBlock : Block {
		private readonly List<Instruction> _instructions;
		private OpCode _branchOpcode;
		private BasicBlock? _fallThrough;
		private BasicBlock? _condTarget;
		private TargetList? _switchTargets;
		private readonly Dictionary<BasicBlock, int> _predecessors;
		private readonly Dictionary<BasicBlock, int> _successors;
#if DEBUG
		internal readonly uint _originalOffset;
#endif

		/// <inheritdoc />
		public override BlockType Type => BlockType.Basic;

		/// <summary>
		/// Instructions in current basic block excluding branch instruction
		/// </summary>
		public IList<Instruction> Instructions => _instructions;

		/// <summary>
		/// Returns <see langword="true"/> if <see cref="Instructions"/> is empty
		/// </summary>
		public bool IsEmpty => _instructions.Count == 0;

		/// <summary>
		/// Returns branch opcode of current basic block
		/// </summary>
		public OpCode BranchOpcode {
			get => _branchOpcode;
			set => _branchOpcode = value;
		}

		/// <summary>
		/// Returns fall through and throws if null
		/// </summary>
		public BasicBlock FallThrough => FallThroughNoThrow ?? throw new ArgumentNullException(nameof(FallThroughNoThrow));

		/// <summary>
		/// Returns fall through of current basic block
		/// </summary>
		public BasicBlock? FallThroughNoThrow {
			get => _fallThrough;
			set => _fallThrough = UpdateReferences(_fallThrough, value);
		}

		/// <summary>
		/// Returns conditional target and throws if null
		/// </summary>
		public BasicBlock CondTarget => CondTargetNoThrow ?? throw new ArgumentNullException(nameof(CondTargetNoThrow));

		/// <summary>
		/// Returns the conditional branch of current basic block (jumps into it if condition is true)
		/// </summary>
		public BasicBlock? CondTargetNoThrow {
			get => _condTarget;
			set => _condTarget = UpdateReferences(_condTarget, value);
		}

		/// <summary>
		/// Returns switch targets and throws if null
		/// </summary>
		public TargetList SwitchTargets => SwitchTargetsNoThrow ?? throw new ArgumentNullException(nameof(SwitchTargetsNoThrow));

		/// <summary>
		/// Returns switch targets of current basic block
		/// </summary>
		public TargetList? SwitchTargetsNoThrow {
			get => _switchTargets;
			set {
				if (value is null) {
					if (_switchTargets is null)
						return;
					_switchTargets.Owner = null;
					_switchTargets = null;
				}
				else {
					if (!(value.Owner is null))
						throw new InvalidOperationException($"{nameof(value)} is already owned by another {nameof(BasicBlock)}.");
					if (!(_switchTargets is null))
						_switchTargets.Owner = null;
					value.Owner = this;
					_switchTargets = value;
				}
			}
		}

		/// <summary>
		/// Returns predecessors of current basic block
		/// </summary>
		public IDictionary<BasicBlock, int> Predecessors => _predecessors;

		/// <summary>
		/// Returns successors of current basic block
		/// </summary>
		public IDictionary<BasicBlock, int> Successors => _successors;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="instructions">Instructions in current basic block excluding branch instruction</param>
		public BasicBlock(IEnumerable<Instruction> instructions) : this(instructions, OpCodes.Ret) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="instructions">Instructions in current basic block excluding branch instruction</param>
		/// <param name="branchOpcode">Branch opcode of current basic block</param>
		public BasicBlock(IEnumerable<Instruction> instructions, OpCode branchOpcode) {
			_instructions = new List<Instruction>(instructions ?? throw new ArgumentNullException(nameof(instructions)));
			_branchOpcode = branchOpcode ?? throw new ArgumentNullException(nameof(branchOpcode));
			_predecessors = new Dictionary<BasicBlock, int>();
			_successors = new Dictionary<BasicBlock, int>();
#if DEBUG
			_originalOffset = _instructions.Count == 0 ? ushort.MaxValue : _instructions[0].Offset;
#endif
		}

		internal BasicBlock? UpdateReferences(BasicBlock? oldValue, BasicBlock? newValue) {
			if (oldValue != newValue) {
				UpdateReferencesCore(_successors, oldValue, newValue);
				if (!(oldValue is null))
					UpdateReferencesCore(oldValue._predecessors, this, null);
				if (!(newValue is null))
					UpdateReferencesCore(newValue._predecessors, null, this);
			}
			return newValue;
		}

		private static void UpdateReferencesCore(Dictionary<BasicBlock, int> references, BasicBlock? oldValue, BasicBlock? newValue) {
			if (!(oldValue is null)) {
				if (references.TryGetValue(oldValue, out int refCount)) {
					if (refCount == 1)
						references.Remove(oldValue);
					else
						references[oldValue] = refCount - 1;
				}
				else {
					throw new InvalidOperationException();
				}
			}
			if (!(newValue is null)) {
				if (references.TryGetValue(newValue, out int refCount))
					references[newValue] = refCount + 1;
				else
					references[newValue] = 1;
			}
		}
	}

	/// <summary>
	/// Scope block
	/// </summary>
	[DebuggerTypeProxy(typeof(DebugView))]
	public abstract class ScopeBlock : Block {
		/// <summary />
		protected List<Block> _blocks;
		/// <summary />
		protected BlockType _type;
		/// <summary />
		protected readonly Dictionary<BasicBlock, int> _entries;
		/// <summary />
		protected readonly Dictionary<BasicBlock, int> _exits;

		/// <summary>
		/// Child blocks
		/// </summary>
		public IList<Block> Blocks => _blocks;

		/// <summary>
		/// First block in current scope block
		/// </summary>
		public Block FirstBlock {
			get => _blocks[0];
			set => _blocks[0] = value;
		}

		/// <summary>
		/// Last block in current scope block
		/// </summary>
		public Block LastBlock {
			get => _blocks[^1];
			set => _blocks[^1] = value;
		}

		/// <summary>
		/// Block type
		/// </summary>
		public override BlockType Type => _type;

		/// <summary>
		/// Returns entries of current scope block
		/// </summary>
		public IDictionary<BasicBlock, int> Entries => _entries;

		/// <summary>
		/// Returns exits of current scope block
		/// </summary>
		public IDictionary<BasicBlock, int> Exits => _exits;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="blocks">Child blocks</param>
		/// <param name="type">Block type</param>
		protected internal ScopeBlock(IEnumerable<Block> blocks, BlockType type) {
			if (blocks is null)
				throw new ArgumentNullException(nameof(blocks));

			_blocks = new List<Block>(blocks);
			_type = type;
			_entries = new Dictionary<BasicBlock, int>();
			_exits = new Dictionary<BasicBlock, int>();
		}

		private sealed class DebugView {
			private readonly Block[] _blocks;

			[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
			public Block[] Blocks => _blocks;

			public DebugView(ScopeBlock scopeBlock) {
				if (scopeBlock is null)
					throw new ArgumentNullException(nameof(scopeBlock));

				_blocks = scopeBlock._blocks.ToArray();
			}
		}
	}

	/// <summary>
	/// Try block
	/// </summary>
	public sealed class TryBlock : ScopeBlock {
		private readonly List<HandlerBlock> _handlers;

		/// <summary>
		/// Handler blocks
		/// </summary>
		public IList<HandlerBlock> Handlers => _handlers;

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="blocks">Child blocks</param>
		public TryBlock(IEnumerable<Block> blocks) : base(blocks, BlockType.Try) {
			_handlers = new List<HandlerBlock>();
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="blocks">Child blocks</param>
		/// <param name="handlers">Handler blocks</param>
		public TryBlock(IEnumerable<Block> blocks, IEnumerable<HandlerBlock> handlers) : base(blocks, BlockType.Try) {
			_handlers = new List<HandlerBlock>(handlers);
		}
	}

	/// <summary>
	/// Filter block
	/// </summary>
	public sealed class FilterBlock : ScopeBlock {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="blocks">Child blocks</param>
		public FilterBlock(IEnumerable<Block> blocks) : base(blocks, BlockType.Filter) {
		}
	}

	/// <summary>
	/// Handler block
	/// </summary>
	public sealed class HandlerBlock : ScopeBlock {
		private FilterBlock? _filter;
		private ITypeDefOrRef? _catchType;

		/// <summary>
		/// Filter block
		/// </summary>
		public FilterBlock? Filter {
			get => _filter;
			set => _filter = value;
		}

		/// <summary>
		/// The catch type if <see cref="Block.Type"/> is <see cref="BlockType.Catch"/>
		/// </summary>
		public ITypeDefOrRef? CatchType {
			get => _catchType;
			set => _catchType = value;
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="blocks">Child blocks</param>
		/// <param name="type">Block type</param>
		/// <param name="catchType">Catch type if exists</param>
		public HandlerBlock(IEnumerable<Block> blocks, BlockType type, ITypeDefOrRef? catchType) : this(blocks, type, null, catchType) {
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="blocks">Child blocks</param>
		/// <param name="type">Block type</param>
		/// <param name="filter">Filter block if exists</param>
		/// <param name="catchType">Catch type if exists</param>
		public HandlerBlock(IEnumerable<Block> blocks, BlockType type, FilterBlock? filter, ITypeDefOrRef? catchType) : base(blocks, type) {
			if (!IsValidHandlerBlockType(type))
				throw new ArgumentOutOfRangeException(nameof(type));

			_filter = filter;
			_catchType = catchType;
		}

		private static bool IsValidHandlerBlockType(BlockType type) {
			return type switch
			{
				BlockType.Catch => true,
				BlockType.Finally => true,
				BlockType.Fault => true,
				_ => false,
			};
		}
	}

	/// <summary>
	/// Method block
	/// </summary>
	public sealed class MethodBlock : ScopeBlock {
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="blocks">Child blocks</param>
		public MethodBlock(IEnumerable<Block> blocks) : base(blocks, BlockType.Method) {
		}
	}
}
